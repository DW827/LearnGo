### 1. go语言slice底层实现原理
##### 切片与数组
+ 在 Go 中，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据。
+ 把第一个大数组传递给函数会消耗很多内存，采用切片的方式传参可以避免上述问题。切片是引用传递，所以它们不需要使用额外的内存并且比使用数组更有效率。
+ 切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型,给定项的切片索引可能比相关数组的相同元素的索引小。
+ 和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个长度可变的数组。
+ Slice 的数据结构定义如下:
```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

##### 切片扩容
1. 扩容策略
1.如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。比如4->8
一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。
2.扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。

2. 扩容是生成全新的内存地址还是在原来的地址后追加
1.原数组还有容量可以扩容，所以执行 append() 操作以后，会在原数组上直接操作，所以这种情况下，扩容以后的数组还是指向原来的数组。这种情况非常危险，极度容易产生 bug,如果原数组上有多个切片，那么这些切片都会被影响！
2.超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。
尽量避免情况一，尽量使用情况二，避免 bug 产生。

##### 切片遍历
```go
for index, value := range slice {

}
// for i,_ := range slice 等于 for i := range slice
```
如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。
由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &slice[index] 获取真实的地址。

##### nil切片和空切片
+ nil slice
nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。
比如函数在发生异常的时候，返回的切片就是 nil 切片。
nil 切片的指针指向 nil。

+ 空 slice
空切片一般会用来表示一个空的集合。
比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片。
```go
slice := make([]int, 0)
slice := []int{}
```

+ 空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。

### 2. go语言map底层实现原理
+ Map是一种通过key来获取value的一个数据结构，其底层存储方式为数组，在存储时key不能重复，当key重复时，value进行覆盖，我们通过key进行hash运算.
+ map同样也是数组存储的的，每个数组下标处存储的是一个bucket,这个bucket的类型见下面代码，每个bucket中可以存储8个kv键值对，当每个bucket存储的kv对到达8个之后，会通过overflow指针指向一个新的bucket，从而形成一个链表.
+ 将所有键打包在一起，将所有值打包在一起.
