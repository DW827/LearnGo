
# MySQL事务
+ 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
+ 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
+ 事务用来管理 insert,update,delete 语句

### ACID
事务是必须满足4个条件（ACID）：
原子性（Atomicity，或称不可分割性）、
一致性（Consistency）、
隔离性（Isolation，又称独立性）、
持久性（Durability）。

>+ 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
>+ 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。
>+ 隔离性：一个事务所做的修改在最终提交以前，对其它事务是不可见的。数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
>+ 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

### 隔离级别
+ set session transaction isolation level 。。。
+ > 未提交读（READ UNCOMMITTED）
事务中的修改，即使没有提交，对其它事务也是可见的。
存在脏读，不可重复读，幻读问题
+ > 已提交读（READ COMMITTED）
如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，一个事务所做的修改在提交之前对其它事务是不可见的。
存在不可重复读，幻读问题
+ > 可重复读（REPEATABLE READ）
在同一个事务中多次读取同一数据的结果是一样的。
存在幻读问题
+ > 串行化（SERIALIZABLE）
以上3种隔离级别都允许对同一条记录进行读-读、读-写、写-读的并发操作，如果我们不允许读-写、写-读的并发操作，可以使用SERIALIZABLE隔离级别，当Session B中的事务更新了id为1的记录后，之后Session A中的事务再去访问这条记录时就被卡住了，直到Session B中的事务提交之后，Session A中的事务才可以获取到查询结果。

### 并发一致性问题
+ >丢失修改：指一个事务的更新操作被另外一个事务的更新操作替换。
解决：一级封锁：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。
+ >存在脏读：某个事务a读到了另一个未提交事务b修改过的记录。如果Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据。
解决：二级封锁：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。
+ >不可重复读：在Session B中提交了几个隐式事务，这些事务都修改了某些记录的值，每次事务提交之后，Session A中的事务都可以查看到最新的值。
解决：三级封锁：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。
+ >幻读：事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了。

##### 事务控制语句
+ BEGIN 或 START TRANSACTION 显式地开启一个事务；

+ COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；

+ ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；

+ SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；

+ RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；

+ ROLLBACK TO identifier 把事务回滚到标记点；

+ SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。
##### 事务处理方法：
MYSQL 事务处理主要有两种方法：
1、用 BEGIN, ROLLBACK, COMMIT来实现
BEGIN 开始一个事务
ROLLBACK 事务回滚
COMMIT 手动事务提交（提交后不能rollback）
2、直接用 SET 来改变 MySQL 的自动提交模式:
SET AUTOCOMMIT=0 禁止自动提交
SET AUTOCOMMIT=1 开启自动提交

### MVCC
+ 多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。
+ MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。
+ 在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。
+ MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。
+ 脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。

##### Undo日志
+ MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。
+ 快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。
+ INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。
##### ReadView
+ MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。
+ 在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：

TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。

TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。

TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：

提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。
可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。
在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。






### 二.如何使用可视化工具操作数据库

### 三.如何在编程语言中操作数据库
