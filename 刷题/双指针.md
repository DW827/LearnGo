# 双指针
+ 1. 力扣167。两数之和
+ 左右双指针
```go
func twoSum(numbers []int, target int) []int {
    if len(numbers) <= 1 {
        return nil
    }
    l, r := 0, len(numbers)-1

    for l < r {
        if numbers[l] + numbers[r] == target {
            return []int{l+1,r+1}
        }
        if numbers[l] + numbers[r] < target {
            l ++
        } else {
            r --
        }
    }
    return nil
}
```
+ 2. 力扣633。平方数之和
+ 左右双指针，math包
```go
func judgeSquareSum(c int) bool {
    // func Floor(x float64) float64,返回不大于x的最小整数（的浮点值）
    l, r := 0, int(math.Floor(math.Sqrt(float64(c))))

    for l <= r {
        if l*l + r*r == c {
            return true
        }
        if l*l + r*r < c {
            l ++
        } else {
            r --
        }
    }
    return false
}
```
+ 3. 力扣345。反转字符串中的元音字母
+ 左右双指针，字符串拆分为字符切片，
strings包，func Contains(s, substr string) bool,判断字符串s是否包含子串substr。
```go
func reverseVowels(s string) string {
    str := "aeiouAEIOU"

    // 将字符串拆分为字符序列
    ans := []byte(s)

    l, r := 0, len(s)-1
    for l <= r {
        for l < r && !strings.Contains(str, string(ans[l])) {
            // 找到左边的元音字母
            l ++
        }
        for l < r && !strings.Contains(str, string(ans[r])) {
            // 找到右边的元音字母
            r --
        }
        // 交换左右的元音字母位置
        ans[l], ans[r] = ans[r], ans[l]
        l ++
        r --
    }
    return string(ans)
}

```
+ 4. 力扣88.合并两个有序数组
+ 两数组两指针
```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    // 从后往前遍历两个要比较的数组
    i, j := m - 1, n - 1
    // 要插入的位置
    k := m + n - 1

    for j >= 0 && i >= 0 {
        if nums1[i] < nums2[j] {
            nums1[k] = nums2[j]
            k --
            j --
        } else {
            nums1[k] = nums1[i]
            k --
            i --
        }
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        k --
        j --
    }
    for i >= 0 {
        nums1[k] = nums1[i]
        k --
        i --
    }
}
```
+ 5. 力扣141.判断链表是否有环
+ 指针，链表遍历
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return false
    }
    p := &ListNode{}
    p = head
    q := p.Next
    // 快慢指针p，q，快每次走一，慢每次走二，有环则会相遇
    for p != nil && q != nil && q.Next != nil{
        if p.Next == q.Next.Next {
            return true
        }
        p = p.Next
        q = q.Next.Next
    } 
    return false
}
```
+ 6. 力扣524.最长的子序列
+ 子序列，不同于连续子串，不能用strings.Contains(s, substr string)。
```go
func findLongestWord(s string, dictionary []string) string {
    // ans存最长子序列
    ans := ""
    if len(s) <= 0 {
        return ans
    }

    for i := range dictionary {
        // 判断当前字符串是否是 s 的子序列
        if isSubstring(s, dictionary[i]) {
            // 若是，则判断是否是最长的那个
            if len(dictionary[i]) > len(ans) || (len(dictionary[i]) == len(ans) && dictionary[i] < ans) {
                // 新的最长子序列
                ans = dictionary[i]
            }
        }
    }

    return ans
}

// 判断是否子序列的解法,注：此处子序列不要求连续，不同于连续的子串
func isSubstring(s , sub string) bool {
    if len(sub) == 0 {
        return true
    }

    i := 0
    j := 0
    for i < len(s) && j < len(sub){
        if s[i] == sub[j] {
            j ++
        }
        i ++
    }
    return j == len(sub)
}

```
