### . 0-1背包问题
##### 元素要么选要么不选，走到目标值
1. dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。
```go
func knapsack(maxw, n int, weights , values []int) [][]int {
    dp := make([][]int, n+1)
    for i := 0; i < n; i ++ {
        dp[i] = make([]int, maxw+1)
    }

    for i:= 1; i <= n; i ++ {
        wi := weights[i-1]
        vi := values[i-1]
        for j:= 1; j <= maxw; j++ {
            if j >= w {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)
            } else {
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[n][maxw]
}
```
2. 空间优化
```go
func knapsack(maxw, n int, weights, values []int) []int {
    dp := make([]int, maxw + 1)
    for i := 1; i <= n; i ++ {
        wi := weights[i-1]
        vi := values[i-1]
        for j := maxw; j >= 1; j-- {
            if j  >= wi {
                dp[j] = max(dp[j], dp[j-w] + v)
            }
        }
    }
    return dp[maxw]
}
```
### 1.分割等和子集
##### [力扣416](https://leetcode-cn.com/problems/partition-equal-subset-sum/)
##### 给定一个只包含正整数的非空数组 \textit{nums}[0]nums[0]，判断是否可以从数组中选出一些数字，使得这些数字的和等于整个数组的元素和的一半。
```go
func canPartition(nums []int) bool {
    n := len(nums)
    if n == 0 {
        return false
    }

    var sum int = 0
    var max int = 0
    for i := 0; i < n; i++ {
        sum += nums[i]
        if nums[i] >= max {
            max = nums[i]
        }
    }
    if sum%2 == 1 {
        return false
    }
    target := sum / 2
    if max > target {
        return false
    }

    // dp[i][j] 表示前 i 个数是否能选出一些数和恰好为 j
    dp := make([][]bool, n)
    for i := 0; i < n; i ++ {
        dp[i] = make([]bool, target+1)
    }

    // 初始化
    // 和为0则必为true
    for i := 0; i < n; i++ {
        dp[i][0] = true
    }
    // i=0，只有一个数，选中和恰好为nums[0]
    dp[0][nums[0]] = true

    for i := 1; i < n; i++ {
        v := nums[i]
        for j := 1; j <= target; j++ {
            if j >= v {
                // 可以不选入也可以选入
                dp[i][j] = dp[i-1][j] || dp[i-1][j-v]
            } else {
                // 不能选入
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[n-1][target]
}

```
```go
// 空间优化
func canPartition(nums []int) bool {
    n := len(nums)
    if n == 0 {
        return false
    }

    var sum int = 0
    var max int = 0
    for i := 0; i < n; i++ {
        sum += nums[i]
        if nums[i] >= max {
            max = nums[i]
        }
    }
    if sum%2 == 1 {
        return false
    }
    target := sum / 2
    if max > target {
        return false
    }

    dp := make([]bool, target+1)
    dp[0] = true

    for i := 1; i < n; i++ {
        v := nums[i]
        for j := target; j >= v; j-- {
            dp[j] = dp[j] || dp[j-v]
        }
    }
    return dp[target]
}

```
### 2.目标和的不同表达式数目
##### 组合，求装满背包有几种方法
##### [力扣494](https://leetcode-cn.com/problems/target-sum/)
```go
// 设 + 的和为 p ，- 的和为 n ， nums和为sum
// p - n = target
// p + n = sum
// 找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2
func findTargetSumWays(nums []int, target int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }

    sum := 0
    for i := 0; i < n; i++ {
        sum += nums[i]
    }
    if sum < target || -sum > target || (sum+target) % 2 == 1 {
        return 0
    }

    // dp[j]表示和等于j的不同表达式数目
    dp := make([]int, (sum+target)/2+1)
    dp[0] = 1

    // 求组合，外for物品n，内for背包target
    for i := 0; i < n; i ++ {
        v := nums[i]
        // 从后往前遍历
        for j := (sum+target)/2; j >= v; j-- {
            dp[j] = dp[j] + dp[j-v]
        }
    }

    return dp[(sum+target)/2]
}

```
### 3. 组合总和Ⅳ
##### [力扣377](https://leetcode-cn.com/problems/combination-sum-iv/)
##### 顺序不同的序列被视作不同的组合。
```go
func combinationSum4(nums []int, target int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }

    // dp[j]表示和等于j的不同排列数目
    dp := make([]int, target+1)
    dp[0] = 1

    // 求排列，外for背包target，内for物品n
	for j:=0;j<=target;j++ {
		for i:=0 ;i < len(nums);i++ {
			if j >= nums[i] {
				dp[j] += dp[j-nums[i]]
			}
		}
	}
	return dp[target]
}

```