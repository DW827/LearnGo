### 1. 最长公共前缀
+ ##### [力扣14](https://leetcode-cn.com/problems/longest-common-prefix/)
+ ##### 字符串排序，字符串比较，字符串数组
```go
func longestCommonPrefix(strs []string) string {
	if len(strs) == 0 {
		return
	}

    ans := strs[0]

	//升序排序
	sort.Slice(strs, func(i, j int) bool {return strs[i] < strs[j]})

	//比较第一个和最后一个
    var i int
	for i = 0; i < len(strs[0]) && i < len(strs[len(strs)-1]); i++{
		if strs[0][i] != strs[len(strs)-1][i] {
			break
		}
	}

	ans = strs[0][:i]
    return ans
}
```
### 2. 最长回文子串
+ ##### [力扣5](https://leetcode-cn.com/problems/longest-palindromic-substring/)
+ ##### 双指针，字符串字符比较大小
```go
func longestPalindrome(s string) string {
	//记录最长回文子串的起始和结束位置 
	start, end := 0, 0
	n := len(s)

	for i := 0; i < n; {
		//左右指针，向两边扩展
		left, right := i, i
		//right指针先走
		for right < n-1 && s[right] == s[right+1]{
		    right ++
		}
		//i到大right所扩展的最长长度的下一个字符
		i = right + 1
		//同时扩大左右指针
		for left > 0 && right < n-1 && s[left-1] == s[right+1]{
			left --
			right ++
		}

		//更新最长回文子串的起始点
		if end-start < right-left {
			 start = left
			 end = right
		}
	}

	return s[start:end+1]
}
```
### 3. 括号匹配
+ ##### [力扣20](https://leetcode-cn.com/problems/valid-parentheses/)
+ ##### 栈的应用，字符串与字符切片，字符串的存储
```go
func isValid(s string) bool {
    ///定义一个栈
    var stack []byte

    if s == "" {
        return true
    }

    for i := 0; i < len(s); i ++ {
        if s[i] == '(' || s[i] == '[' || s[i] == '{' {
            //左括号入栈
            stack = append(stack, s[i])
            continue
        }

        if len(stack) <=0 {
            //栈空
            return false
        }
        //右括号出栈比较是否匹配
        if (s[i] == ')' && stack[len(stack)-1] == '(' ||
        s[i] == ']' && stack[len(stack)-1] == '[' ||
        s[i] == '}' && stack[len(stack)-1] == '{') {
            //匹配，栈顶出栈
            stack = stack[:len(stack)-1]
        }else{
            return false
        }
    }

    return len(stack) == 0
}
```
+ ##### 哈希，map应用，make([]type, len, cap)
```go
func isValid(s string) bool {
    hash := map[byte]byte{')':'(', ']':'[', '}':'{'}
    stack := make([]byte, 0)
    if s == "" {
        return true
    }

    for i := 0; i < len(s); i++ {
        if s[i] == '(' || s[i] == '[' || s[i] == '{' {
            stack = append(stack, s[i])
        } else if len(stack) > 0 && stack[len(stack)-1] == hash[s[i]] {
            stack = stack[:len(stack)-1]
        } else {
            return false
        }
    }
    return len(stack) == 0
}
```

### 4. 字母异位词分组
##### [力扣49]()
##### 哈希。map。排序。字符串比较
```go
func groupAnagrams(strs []string) [][]string {
    ans := [][]string{}
    mp := map[string][]string{}
    l := len(strs)
    
    for i := 0; i < l; i++ {
        // 单词转字符数组
		chars := []rune(strs[i])
		// 排序字符数组
		sort.Slice(chars, func(i, j int) bool {
			return chars[i] < chars[j]
		})
		// 排序后的字符数组转为string，作为哈希值
		key := string(chars)

        mp[key] = append(mp[key], string(strs[i]))
    }
    for _, v := range mp {
        ans = append(ans, v)
    }
    return ans
}
```