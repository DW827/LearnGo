### 1. 合并两个有序链表,升序
##### [力扣21](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    L := &ListNode{}    //新建空头结点
    p := L      //工作指针
    for list1 != nil && list2 != nil {
        if list1.Val < list2.Val {
            p.Next = list1
            list1 = list1.Next
        }else{
            p.Next = list2
            list2 = list2.Next
        }
        p = p.Next
    }
    for list1 != nil {
        p.Next = list1
        p = p.Next
        list1 = list1.Next
    }
    for list2 != nil {
        p.Next = list2
        p = p.Next
        list2 = list2.Next
    }
    return L.Next   //返回首元节点
}
```
### 2.合并K个有序链表
##### [力扣23]()
##### 小根堆，优先级队列。
用容量为K的小根堆优先队列，把链表的头结点都放进去，然后出队当前优先队列中最小的，挂上链表，然后让出队的那个节点的下一个入队，再出队当前优先队列中最小的，直到优先队列为空。
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeKLists(lists []*ListNode) *ListNode {
    // 建立容量为K的小根堆
    h := new(minHeap)
    for i := 0; i < len(lists); i++ {
        if lists[i] != nil {
            heap.Push(h, lists[i])
        }
    }

    Head := new(ListNode)    // 新建空头结点
    p := Head           // 工作指针

    for h.Len() > 0 {
        temp := heap.Pop(h).(*ListNode)
        if temp.Next != nil {
            heap.Push(h, temp.Next)
        }
        p.Next = temp
        p = p.Next
    }

    return Head.Next    // 返回合并后的链表首元结点
}
// 定义小根堆类型
type minHeap []*ListNode

// 为小根堆绑定方法
// 实现Sort接口，升序
func (h minHeap) Len()          int { return len(h) }
func (h minHeap) Less(i, j int) bool { return h[i].Val < h[j].Val }
func (h minHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
// 实现container/Heap接口
// 向末尾添加元素
// 从末尾删除元素
func (h *minHeap) Push(x interface{}) { *h = append(*h, x.(*ListNode)) }
func (h *minHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]       // 数组最后一个元素
    *h = old[0:n-1]
    return x
}
```
### 3. 二叉树中序遍历[94](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)
##### 递归，切片，make([]value, len, cap)
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
var ans []int

func inorderTraversal(root *TreeNode) []int {
    if root == nil {
        return nil
    }
    ans = make([]int, 0)
    inorder(root)
    return ans
}

func inorder(root *TreeNode) {
    if root.Left != nil {
        inorder(root.Left)
    }
    ans = append(ans, root.Val)
    if root.Right != nil {
        inorder(root.Right)
    }
}
```
##### 栈
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) []int {
    if root == nil {
        return nil
    }
    stack := Stack([]*TreeNode{})    // 初始化栈
    ans := []int{}
    p := root   // 工作指针
    for len(stack) > 0 || p != nil {
        if p != nil {   // 一路向左
            stack.Push(p)
            p = p.Left
        } else {
            p = stack.Pop()     // 出栈
            ans = append(ans, p.Val)    // 访问栈顶元素
            p = p.Right     // 往右
        }
    }
	return ans
}

// 实现栈:结点指针的数组(切片)，入栈方法，出栈方法。
type Stack []*TreeNode

func (s *Stack) Push(node *TreeNode) {
	*s = append(*s, node)   // 入栈
}

func (s *Stack) Pop() *TreeNode {
    if len(*s) == 0 {   // 栈空返回nil
        return nil
    }
	x := (*s)[len(*s)-1]    // 栈顶元素出栈
	*s = (*s)[:len(*s)-1]
	return x
}

```