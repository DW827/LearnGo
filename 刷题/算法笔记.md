### 1.最长不重复子串长度
+ ##### [力扣3](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
+ ##### 滑动窗口法，哈希，map[key]value.
+ code
```go
func lengthOfLongestSubstring(s string) int {
    length := len(s)
	ans := 0
    //索引为字符对应编码，值记录每个字符的位置
	cmap := map[byte]int{}

    //滑动窗口左右指针left，right
	left := 0
	for right := 0; right < length; right++ {
		//求字符的Unicode
		index := s[right]

		//若当前字符出现过，将左指针移动到该字符下标的下一个位置
		left = max(left, cmap[index])

		//记录当前字符下标的下一个位置
		cmap[index] = right + 1

        //更新滑动窗口大小
		ans = max(ans, right-left+1)
	}
	return ans
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```
### 2. 寻找两个升序数组的中位数
+ ##### [力扣4](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)
+ ##### 遍历数组
+ code
```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    i, j, k := 0, 0, 1
    //偶数个时的中间两个数pre，med，奇数个时的中位数med
    pre, med := 0, 0

    len1, len2 := len(nums1), len(nums2)
    len3 := len1 + len2
    mid := len3 / 2 + 1
    //寻找第k小数，用med保存，k是中位数的位置
    for k <= mid {
        pre = med   //pre暂存偶数个时的中间前一个数

        if i < len1 && j < len2 {
            if nums1[i] < nums2[j] {
                med = nums1[i]
                i++
            } else {
                med = nums2[j]
                j++
            }
        } else if i < len1 {
            med = nums1[i]
            i++
        } else {
            med = nums2[j]
            j++
        }
        k++
    }//for
    if len3 % 2 == 0 {
        return float64(pre + med) / 2
    }
    return float64(med)
}
```
### 3. 三数之和
+ ##### [力扣15](https://leetcode-cn.com/problems/3sum/)
+ ##### 排序+双指针，切片数组[][]type.
+ code
```go
func threeSum(nums []int) [][]int {
    ans := [][]int{}
    if nums == nil || len(nums) < 3 {
        return ans
    }
    sort.Ints(nums)//排序，升序
    //从小到大，每次固定一个数，从后面的首尾向内查看另外两个数
    for i := 0; i < len(nums)-2; i++ {
        if nums[i] > 0 {
            //若固定数大于零，后面必然没有和为零的三元组，跳出for循环
            break
        }
        if i > 0 && nums[i] == nums[i-1] {
            //若固定数跟上一个数相同，在上一次已经判断过了，跳过本次循环
            continue
        }
        left := i + 1
        right := len(nums) - 1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                res := []int{nums[i], nums[left], nums[right]}
                ans = append(ans, res)
                //去重
                for left < right && nums[left] == nums[left+1] {
                    left ++
                }
                for left > right && nums[right] == nums[right-1] {
                    right --
                }
                //找出所有满足的三元组
                left ++
                right --
            }else if sum > 0 {
                right --
            }else {
                left ++
            }
        }//for left < right
    }// for i < len(nums)-2
    return ans
}
```

### 4.下一个排列
##### [力扣31](https://leetcode-cn.com/problems/next-permutation/)
##### 排序，下一个更大的整数
```go
func nextPermutation(nums []int)  {
    if len(nums) <= 1 {
        return
    }
    r := len(nums)-1
    p := len(nums)-2
    // 从后往前遍历相邻两元素，找到nums[p]<nums[r]
    for p >= 0 && nums[p] >= nums[r] {
        p --
        r --
    }

    i := len(nums)-1
    if p >= 0 {
        // 从后往前遍历(r,...)，找到第一个满足nums[p]<nums[i]
        for nums[p] >= nums[i] {
            i --
        }
        nums[p], nums[i] = nums[i], nums[p]
    }
    // 将r之后的序列升序
    sort.Ints(nums[r:])
    return
}
```

### 5. 原地旋转矩阵
##### []()
##### 矩阵原地旋转：水平翻转+对角翻转
```go
func rotate(matrix [][]int)  {
    n := len(matrix)
    // 原地顺时针旋转矩阵
    // 水平翻转
    for r := 0; r < n; r++ {
        for c := 0; c < n/2; c++ {
            matrix[r][c], matrix[r][n-c-1] = matrix[r][n-c-1], matrix[r][c]
        }
    }
    // 右对角翻转
    for r := 0; r < n; r++ {
        for c := 0; c < n-r; c++ {
            matrix[r][c], matrix[n-c-1][n-r-1] = matrix[n-c-1][n-r-1], matrix[r][c]
        }
    }
}
```

### 6. 区域和检索 - 数组不可变
##### [力扣303](https://leetcode-cn.com/problems/range-sum-query-immutable/)
##### 构造数组，前缀和。
```go
type NumArray struct {
    nums []int
}

func Constructor(nums []int) NumArray {
    l := len(nums)
    // 构建长度为 len(nums)+1 的数组，未初始化，值为零
    newnums := make([]int, l+1)
    for i := 0; i < l; i ++ {
        // 新数组暂存前缀和,从下标为1开始存
        newnums[i+1] = nums[i] + newnums[i]
    }
    return NumArray{newnums}
}

func (this *NumArray) SumRange(left int, right int) int {
    // 求区间和
    return this.nums[right+1] - this.nums[left]
}

/**
 * Your NumArray object will be instantiated and called as such:
 * obj := Constructor(nums);
 * param_1 := obj.SumRange(left,right);
 */
```