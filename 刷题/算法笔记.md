### 1.最长不重复子串长度
+ ##### [力扣3](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
+ ##### 滑动窗口法，哈希，map[key]value.
+ code
```go
func lengthOfLongestSubstring(s string) int {
    length := len(s)
	ans := 0
    //索引为字符对应编码，值记录每个字符的位置
	cmap := map[byte]int{}

    //滑动窗口左右指针left，right
	left := 0
	for right := 0; right < length; right++ {
		//求字符的Unicode
		index := s[right]

		//若当前字符出现过，将左指针移动到该字符下标的下一个位置
		left = max(left, cmap[index])

		//记录当前字符下标的下一个位置
		cmap[index] = right + 1

        //更新滑动窗口大小
		ans = max(ans, right-left+1)
	}
	return ans
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```
### 2. 寻找两个升序数组的中位数
+ ##### [力扣4](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)
+ ##### 遍历数组
+ code
```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    i, j, k := 0, 0, 1
    //偶数个时的中间两个数pre，med，奇数个时的中位数med
    pre, med := 0, 0

    len1, len2 := len(nums1), len(nums2)
    len3 := len1 + len2
    mid := len3 / 2 + 1
    //寻找第k小数，用med保存，k是中位数的位置
    for k <= mid {
        pre = med   //pre暂存偶数个时的中间前一个数

        if i < len1 && j < len2 {
            if nums1[i] < nums2[j] {
                med = nums1[i]
                i++
            } else {
                med = nums2[j]
                j++
            }
        } else if i < len1 {
            med = nums1[i]
            i++
        } else {
            med = nums2[j]
            j++
        }
        k++
    }//for
    if len3 % 2 == 0 {
        return float64(pre + med) / 2
    }
    return float64(med)
}
```
### 3. 三数之和
+ ##### [力扣15](https://leetcode-cn.com/problems/3sum/)
+ ##### 排序+双指针，切片数组[][]type.
+ code
```go
func threeSum(nums []int) [][]int {
    ans := [][]int{}
    if nums == nil || len(nums) < 3 {
        return ans
    }
    sort.Ints(nums)//排序，升序
    //从小到大，每次固定一个数，从后面的首尾向内查看另外两个数
    for i := 0; i < len(nums)-2; i++ {
        if nums[i] > 0 {
            //若固定数大于零，后面必然没有和为零的三元组，跳出for循环
            break
        }
        if i > 0 && nums[i] == nums[i-1] {
            //若固定数跟上一个数相同，在上一次已经判断过了，跳过本次循环
            continue
        }
        left := i + 1
        right := len(nums) - 1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                res := []int{nums[i], nums[left], nums[right]}
                ans = append(ans, res)
                //去重
                for left < right && nums[left] == nums[left+1] {
                    left ++
                }
                for left > right && nums[right] == nums[right-1] {
                    right --
                }
                //找出所有满足的三元组
                left ++
                right --
            }else if sum > 0 {
                right --
            }else {
                left ++
            }
        }//for left < right
    }// for i < len(nums)-2
    return ans
}
```
### 4. 最长公共前缀
+ ##### [力扣14](https://leetcode-cn.com/problems/longest-common-prefix/)
+ ##### 字符串排序，字符串比较，字符串数组
```go
func longestCommonPrefix(strs []string) string {
	if len(strs) == 0 {
		return
	}

    ans := strs[0]

	//升序排序
	sort.Slice(strs, func(i, j int) bool {return strs[i] < strs[j]})

	//比较第一个和最后一个
    var i int
	for i = 0; i < len(strs[0]) && i < len(strs[len(strs)-1]); i++{
		if strs[0][i] != strs[len(strs)-1][i] {
			break
		}
	}

	ans = strs[0][:i]
    return ans
}
```
### 5. 最长回文子串
+ ##### [力扣5](https://leetcode-cn.com/problems/longest-palindromic-substring/)
+ ##### 双指针，字符串字符比较大小
```go
func longestPalindrome(s string) string {
	//记录最长回文子串的起始和结束位置 
	start, end := 0, 0
	n := len(s)

	for i := 0; i < n; {
		//左右指针，向两边扩展
		left, right := i, i
		//right指针先走
		for right < n-1 && s[right] == s[right+1]{
		    right ++
		}
		//i到大right所扩展的最长长度的下一个字符
		i = right + 1
		//同时扩大左右指针
		for left > 0 && right < n-1 && s[left-1] == s[right+1]{
			left --
			right ++
		}

		//更新最长回文子串的起始点
		if end-start < right-left {
			 start = left
			 end = right
		}
	}

	return s[start:end+1]
}
```
### 6. 括号匹配
+ ##### [力扣20](https://leetcode-cn.com/problems/valid-parentheses/)
+ ##### 栈的应用，字符串与字符切片，字符串的存储
```go
func isValid(s string) bool {
    ///定义一个栈
    var stack []byte

    if s == "" {
        return true
    }

    for i := 0; i < len(s); i ++ {
        if s[i] == '(' || s[i] == '[' || s[i] == '{' {
            //左括号入栈
            stack = append(stack, s[i])
            continue
        }

        if len(stack) <=0 {
            //栈空
            return false
        }
        //右括号出栈比较是否匹配
        if (s[i] == ')' && stack[len(stack)-1] == '(' ||
        s[i] == ']' && stack[len(stack)-1] == '[' ||
        s[i] == '}' && stack[len(stack)-1] == '{') {
            //匹配，栈顶出栈
            stack = stack[:len(stack)-1]
        }else{
            return false
        }
    }

    return len(stack) == 0
}
```
+ ##### 哈希，map应用，make([]type, len, cap)
```go
func isValid(s string) bool {
    hash := map[byte]byte{')':'(', ']':'[', '}':'{'}
    stack := make([]byte, 0)
    if s == "" {
        return true
    }

    for i := 0; i < len(s); i++ {
        if s[i] == '(' || s[i] == '[' || s[i] == '{' {
            stack = append(stack, s[i])
        } else if len(stack) > 0 && stack[len(stack)-1] == hash[s[i]] {
            stack = stack[:len(stack)-1]
        } else {
            return false
        }
    }
    return len(stack) == 0
}
```

### 7.下一个排列
##### [力扣31](https://leetcode-cn.com/problems/next-permutation/)
##### 排序，下一个更大的整数
```go
func nextPermutation(nums []int)  {
    if len(nums) <= 1 {
        return
    }
    r := len(nums)-1
    p := len(nums)-2
    // 从后往前遍历相邻两元素，找到nums[p]<nums[r]
    for p >= 0 && nums[p] >= nums[r] {
        p --
        r --
    }

    i := len(nums)-1
    if p >= 0 {
        // 从后往前遍历(r,...)，找到第一个满足nums[p]<nums[i]
        for nums[p] >= nums[i] {
            i --
        }
        nums[p], nums[i] = nums[i], nums[p]
    }
    // 将r之后的序列升序
    sort.Ints(nums[r:])
    return
}
```

### 8. 原地旋转矩阵
##### []()
##### 矩阵原地旋转：水平翻转+对角翻转
```go
func rotate(matrix [][]int)  {
    n := len(matrix)
    // 原地顺时针旋转矩阵
    // 水平翻转
    for r := 0; r < n; r++ {
        for c := 0; c < n/2; c++ {
            matrix[r][c], matrix[r][n-c-1] = matrix[r][n-c-1], matrix[r][c]
        }
    }
    // 右对角翻转
    for r := 0; r < n; r++ {
        for c := 0; c < n-r; c++ {
            matrix[r][c], matrix[n-c-1][n-r-1] = matrix[n-c-1][n-r-1], matrix[r][c]
        }
    }
}
```
### 9. 字母异位词分组
##### [力扣49]()
##### 哈希。map。排序。字符串比较
```go
func groupAnagrams(strs []string) [][]string {
    ans := [][]string{}
    mp := map[string][]string{}
    l := len(strs)
    
    for i := 0; i < l; i++ {
        // 单词转字符数组
		chars := []rune(strs[i])
		// 排序字符数组
		sort.Slice(chars, func(i, j int) bool {
			return chars[i] < chars[j]
		})
		// 排序后的字符数组转为string，作为哈希值
		key := string(chars)

        mp[key] = append(mp[key], string(strs[i]))
    }
    for _, v := range mp {
        ans = append(ans, v)
    }
    return ans
}
```
### 10. 最长连续有效括号
##### [力扣32](https://leetcode-cn.com/problems/longest-valid-parentheses/)
```go
func longestValidParentheses(s string) int {
    l := len(s)
    if l <= 1 {
        return 0
    }
    str := []byte(s)
    max := 0
    stack := []int{-1}  // 栈底暂存一个-1，用来防止空栈pop错误
    for i := 0; i < l; i++ {
        if str[i] == '(' {
            // 遇到'('下标入栈
            stack = append(stack, i)
        } else {
            // 遇到')'栈顶出栈
            stack = stack[:len(stack)-1]
            if len(stack) == 0 {
                // 如果出栈导致栈空，说明连续有效括号被')'分割，将当前的')'下标入栈，作用同上
                stack = append(stack, i)
            } else {
                // 如果出栈了栈不空，说明有效括号依然连续，更新最长长度
                if max <= i - stack[len(stack)-1] {
                    max = i - stack[len(stack)-1]
                }
            }
        }
    }
    return max
}

```