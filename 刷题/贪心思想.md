### 1. 连续子数组最大和[力扣53](https://leetcode-cn.com/problems/maximum-subarray/)

##### 贪心思想

```go
func maxSubArray(nums []int) int {
    if len(nums) == 1 {
        return nums[0]
    }
    prenums := nums[0]
    max := prenums
    for i := 1; i < len(nums); i++ {
        // 更新上一个连续子数组
        if prenums > 0 {
            // 变长
            prenums = prenums + nums[i]
        } else {
            // 重新找连续数组
            prenums = nums[i]
        }
        // 更新最大和
        if prenums > max {
            max = prenums
        }
    }
    return max
}
```

### 2. 买股票的最佳时机Ⅰ[力扣121]()

##### 贪心思想

##### 题目描述：一次股票交易包含买入和卖出，只进行一次交易，求最大收益

只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。

```go
func maxProfit(prices []int) int {
    if len(prices) == 1 {
        return 0
    }
    // 之前的最低价格
    premin := prices[0]
    max := prices[1] - premin
    for i := 1; i < len(prices); i++ {
        // 更新最低价格
        if prices[i] < premin {
            premin = prices[i]
        }
        // 更新最大利润
        if prices[i] - premin > max {
            max = prices[i] - premin
        }
    }
    if max > 0 {
        return max
    } else {
        return 0
    }
}
```

### 3. 买股票的最佳时机Ⅱ[力扣122](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

##### 贪心思想

```go
func maxProfit(prices []int) int {
    if len(prices) == 1 {
        return 0
    }
    // 今天买，明天卖，明天买，后天卖。。。
    max := 0
    for i := 1; i < len(prices); i++ {
        // 连续两天买卖利润大于等于零即可
        if prices[i] - prices[i-1] >= 0 {
            max = max + prices[i] - prices[i-1]
        }
    }
    return max
/*     if max > 0 {
        return max
    } else {
        return 0
    } */
}
```

### 4. 跳跃游戏[力扣55](https://leetcode-cn.com/problems/jump-game/)

```go
func canJump(nums []int) bool {
    l := len(nums)
    pre := nums[0]
    max := pre
    // max记录可以跳到的最远
    for i := 1; i < l && i <= max; i++ {
        // 出现更远，更新max
        if nums[i] + i > max {
            max = nums[i] + i
        }
    }
    if max >= l-1 {
        return true
    }
    return false
}
```

### 5. 分发饼干[力扣455](https://leetcode-cn.com/problems/assign-cookies/)

```go
func findContentChildren(g []int, s []int) int {
    if len(s) == 0 {
        return 0
    }
    // 用最小的饼干先满足小胃口的孩子
    sort.Ints(s)
    sort.Ints(g)
    gi := 0
    si := 0
    for gi < len(g) && si < len(s) {
        if s[si] >= g[gi] {
            gi ++
        }
        si ++
    }
    return gi
}
```

### 6. 用最少数量的箭引爆气球
##### 力扣452
```go
func findMinArrowShots(points [][]int) int {
    // 按右边界排序
    sort.Slice(points, func(i, j int)bool{
        return points[i][1] < points[j][1]
    })

    // 计算不重叠区间个数
    l := len(points)
    ans := 1
    temp := points[0]
    for i := 1; i < l; i++ {
        if temp[1] >= points[i][0] {        // 出现重复左
            continue
        }
        ans ++
        temp = points[i]
    }
    return ans
}
```
### 7. 合并区间
##### [力扣56](https://leetcode-cn.com/problems/merge-intervals/)
##### sort排序包，切片排序，自定义排序，贪心。
```go
func merge(intervals [][]int) [][]int {
    l := len(intervals)
    if l == 1 {
        return intervals
    }
    ans := [][]int{}
    // 按左边界排序
    sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})

    temp := intervals[0]
    for i := 1; i < l; i++ {
        if temp[1] >= intervals[i][0] {     // 出现重复左
            if temp[1] < intervals[i][1] {  // 更新右为最大
                temp[1] = intervals[i][1]   // 合并
            }
        } else {
            ans = append(ans, temp)
            temp = intervals[i]
        }
    }
    ans = append(ans, temp)     // 注意最后一个别忘了加
    return ans
}

```
