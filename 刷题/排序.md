### 1. 堆排
```go
// 满足公式 A[i]<A[2*i+1] &&A[i]<A[2*i+2]
func heapSort(input []int) {
	inputLen := len(input)
	if inputLen == 0 {
		return
	}
	for i := 0; i < inputLen; i++ {
        // 每次循环一个最小的将移动到根，也就是堆顶
		minAjust(input[i:])
	}
}

func minAjust(input []int) {
	inputLen := len(input)
	if inputLen <= 1 {
		return
	}
    // 自下往上，将树中最小的移动到根
	for i := inputLen/2 - 1; i >= 0; i-- {
		if (2*i+1 <= inputLen-1) && (input[i] >= input[2*i+1]) {
			input[i], input[2*i+1] = input[2*i+1], input[i]
		}
		if (2*i+2 <= inputLen-1) && (input[i] >= input[2*i+2]) {
			input[i], input[2*i+2] = input[2*i+2], input[i]
		}
	}
}
```
### 2. 快排
1. 
```go
import "math/rand"

func quicksort(nums []int, l, r int) {
    if l < r {
        p := partition(nums, l, r)

        quicksort(nums, l, p-1)
        quicksort(nums, p+1, r)
    }
}
// 划分
func partition(nums []int, l, r int) int {
    m := rand.Int()%(right-left+1)+left
    p := nums[m]
    for l < r {
        for l < r && nums[r] > p {
            r --
        }
        nums[r] = nums[l]

        for l < r && nums[l] < p {
            l ++
        }
        nums[l] = nums[r]
    }
    // 循环结束时，l==r
    nums[l] = p
    return l
}
```
2. 
```go
func quicksort(nums []int, l, r int) {
    if l < r {
        p := partition(nums, l, r)

        quicksort(nums, l, p-1)
        quicksort(nums, p+1, r)
    }
}
// 划分
func partition(nums []int, l, r int) int {
    m := rand.Int()%(r-l+1)+l
    p := nums[m]
    nums[l],nums[i]=nums[i],nums[l]
    i := l
    j := r
    for i<j{
        for i<j&&nums[j]>=p{
            j--
        }
        for i<j&&nums[i]<=p{
            i++
        }
        nums[i],nums[j]=nums[j],nums[i]
    }
    nums[l],nums[i]=nums[i],nums[l]
    return l
}
```