### 1. 爬楼梯
##### [力扣70](https://leetcode-cn.com/problems/climbing-stairs/)
##### 动态规划DP，或递归。优：动态规划
假设 n = 5，有 5 级楼梯要爬
题意说，每次有2种选择：爬1级，或，爬2级。
如果爬1级，则剩下4级要爬。
如果爬2级，则剩下3级要爬。
这拆分出 2 个问题：
爬4级楼梯有几种方式？
爬3级楼梯有几种方式？
于是，爬 5 级楼梯的方式数 = 爬 4 级楼梯的方式数 + 爬 3 级楼梯的方式数。
1. 数组含义：dp[i]表示从 0 到 i 一共有多少种不同爬楼梯方式；
2. 递推公式：dp[i] = dp[i-1] + dp[i-2];（每次爬一级或两级）
3. 初始条件：dp[0] = 1, dp[1] = 1;
4. 从前往后遍历;
```go
func climbStairs(n int) int {
	dp := make([]int, n+1)
	dp[0] = 1
	dp[1] = 1

	for i := 2; i < len(dp); i++ {
		dp[i] = dp[i-2] + dp[i-1]
	}
	return dp[n]
}
// 或
func climbStairs(n int) int {
    pre := 1
    cur := 1
    for i := 2; i < n+1; i++ {
        temp := cur
        cur = pre + cur
        pre = temp
    }
    return cur
}
```
### 2. 不同路径
##### [力扣62]()
##### 动态规划，二维数组初始化和遍历。
1. 二维数组dp[i][j]，表示从(0，0) 到 (i,j) 一共 有多少条不同路径;
2. dp[i][j] = dp[i-1][j] + dp[i][j-1];
3. dp[i][0] = 1, dp[0][j] = 1;
4. 从前往后遍历；
```go
func uniquePaths(m int, n int) int {
    if m <= 1 {
        return 1
    }
    dp := make([][]int, m)

    // 初始化条件
    for i := 0; i < m; i++ {
        dp[i] = make([]int, n)
        dp[i][0] = 1
    }
    for j := 0; j < n; j++ {
        dp[0][j] = 1
    }

    // 遍历递推公式
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }

    return dp[m-1][n-1]
}
```