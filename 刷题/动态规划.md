### 1. 爬楼梯
##### [力扣70](https://leetcode-cn.com/problems/climbing-stairs/)
##### 动态规划DP，或递归。优：动态规划
假设 n = 5，有 5 级楼梯要爬
题意说，每次有2种选择：爬1级，或，爬2级。
如果爬1级，则剩下4级要爬。
如果爬2级，则剩下3级要爬。
这拆分出 2 个问题：
爬4级楼梯有几种方式？
爬3级楼梯有几种方式？
于是，爬 5 级楼梯的方式数 = 爬 4 级楼梯的方式数 + 爬 3 级楼梯的方式数。
1. 数组含义：dp[i]表示从 0 到 i 一共有多少种不同爬楼梯方式；
2. 递推公式：dp[i] = dp[i-1] + dp[i-2];（每次爬一级或两级）
3. 初始条件：dp[0] = 1, dp[1] = 1;
4. 从前往后遍历;
```go
func climbStairs(n int) int {
	dp := make([]int, n+1)
	dp[0] = 1
	dp[1] = 1

	for i := 2; i < len(dp); i++ {
		dp[i] = dp[i-2] + dp[i-1]
	}
	return dp[n]
}
// 或
func climbStairs(n int) int {
    pre := 1
    cur := 1
    for i := 2; i < n+1; i++ {
        temp := cur
        cur = pre + cur
        pre = temp
    }
    return cur
}
```
### 2. 不同路径数
##### [力扣62]()
##### 动态规划，二维数组初始化和遍历。
1. 二维数组dp[i][j]，表示从(0，0) 到 (i,j) 一共 有多少条不同路径;
2. dp[i][j] = dp[i-1][j] + dp[i][j-1];
3. dp[i][0] = 1, dp[0][j] = 1;
4. 从前往后遍历；
```go
func uniquePaths(m int, n int) int {
    dp := make([][]int, m)

    // 初始化条件
    for i := 0; i < m; i++ {
        dp[i] = make([]int, n)
        dp[i][0] = 1
    }
    for j := 0; j < n; j++ {
        dp[0][j] = 1
    }

    // 遍历递推公式
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            // 只能从左边和上边下来
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }

    return dp[m-1][n-1]
}
```

### 3. 不同路径数Ⅱ
##### [力扣63](https://leetcode-cn.com/problems/unique-paths-ii/)
##### 动态规划，二维数组遍历和初始化。
1. 
2. 
```go
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
    m := len(obstacleGrid)
    n := len(obstacleGrid[0])
    dp := make([][]int, m)

    for i := 0; i < m ; i ++ {
        dp[i] = make([]int, n)
    }
    // 初始化条件
    // 如果是障碍物, 后面的就都是0, 不用循环了
    for i := 0; i < m && obstacleGrid[i][0] == 0; i ++ {
        dp[i][0] = 1
    }
    for j := 0; j < n && obstacleGrid[0][j] == 0; j ++ {
        dp[0][j] = 1
    }

    // 遍历递推公式
    for i := 1; i < m; i ++ {
        for j := 1; j < n; j ++ {
            if obstacleGrid[i][j] == 1 {
                // 如果obstacleGrid[i][j]这个点是障碍物, 那么我们的dp[i][j]保持为0
                continue
            }
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
}
```
### 4. 
##### [力扣64](https://leetcode-cn.com/problems/minimum-path-sum/)

```go
func minPathSum(grid [][]int) int {
    m := len(grid)
    n := len(grid[0])
    dp := make([][]int, m)
    for i := 0; i < m; i++ {
        dp[i] = make([]int, n)
    }

    // 初始化
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }

    // 遍历递推公式
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            // 更新为最小权值和
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func min(x, y int) int {
    if x > y {
        return y
    } else {
         return x
    }
}
```